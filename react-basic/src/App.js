import logo from "./logo.svg";
import "./App.css";

/*

node.js
-자바스크립트를 브라우저 밖에서도 실행할 수 있게 해주는 환경
-npm/yarn을 이용해서 관련된 모듈을 설치
-babel, webpack을 사용하기 위해서 설치

ssr(server side rendering)과 csr(client side rendering)

ssr(server side rendering)
전통적으로 만들어지는 페이지를 의미
서버에서 페이지를 전달받아서 바로 렌더링하는 방식(완성되어 있는 페이지)
html, css, script가 모두 구현된 상태가 사용자에게 전달되는 방식
-초기 로딩속도는 빠른편, seo(검색엔진)에서도 유리한 편
-초기 속도는 빠르지만 업데이트가 되면서 랜더링을 하는 경우 모든 페이지를 새로 랜더링 하기
때문에 속도가 느리거나 과부하의 원인이 된다.
-스크립트의 사용빈도가 동적인 효과를 구현하는데에서 끝남

csr(client side rendering)
-vue나 react로 만들어지는 spa(싱글 페이지 어플리케이션)방식의 페이지를 의미
-초기로딩속도는 느리지만(한번에 모든 정보를 받으므로) 업데이트 될때에는 필요한 부분만
랜더링이 되기 때문에 과부하의 염려가 적고 속도가 빠름
-seo에서는 다소 불리한 위치

하이브리드 rendering
next.js


리액트
리액트는 ui를 하나의 구성으로 보지 않고 여러개의 컴포넌트로 쪼개서 따로따로 관리한다.
쪼개진 컴포넌트들은 상태(로그인, 화면의 업데이트)가 업데이트 되면 그 부분만 리랜더링을 해서
정보를 변경하는 방식으로 메모리의 소모를 줄이는 역할을 하기 때문에 상태가 업데이트 될때마다
페지이가 로딩되는 시간이 줄어든다

가상dom
리액트에서는 dom객체를 직접적으로 조작하는 것을 금지하고 있다.
컴포넌트의 상태가 변경되면 리액트는 가상dom에 변경된 내용을 반영해서 실제dom과
가상의 dom을 서로 비교해서 변경된 부분만 실제 dom에 적용하는 방식으로 최소한의 dom조작을 
통해 ui를 업데이트 하는 것을 목표로 하고 있다.


리액트 - 자바스크립트 기반 ui 제작 라이브러리
리액트는 오직 ui를 구성하는 목적으로 만들어진 툴이기 때문에 상태관리나 라우팅 같은 요소들은
다른 라이브러리를 설치해서 사용해야 한다
다만 사용자가 프로젝트에 맞게 필요한 요소들만 선택해서 사용할 수 있기 때문에 관리면에서는
장점을 가지고 있다

뷰 - 자바스크립트 기반 ui 제작 라이브러리
ui를 구성하는데 필요한 기능을 거의 모든 기능들을 내장하고 있기 때문에 따로 추가적인
라이브러리를 설치 안해도 된다.

리액트에서 변경되는 점
jsx문법(javascript XML)문법
확장형 스크립트 문법 HTML과 비슷한 문법으로 사용해서 난이도가 낮은 편
일반 스크립트 문법이 아니기 때문에 babel로 변환하는 작업이 필요하다

jsx문법 규칙
1. 컴포넌트(js,jsx문서)안에 있는 여러개의 태그들은 반드시 하나의 부모의 태그가 있어야 한다.
react에서 가상의 dom이 컴포넌트를 감지할때 하나의 태그만 인식하도록 설계되어 있기 때문에
보통 div로 감싸는게 일반적이지만 깔끔한 코드를 원한다면 <></> (fragment)처럼 부모 태그로 감쌀수도 있다.

2. 자바스크립트 표현식을 사용할 수 있다.

3.if문을 사용하지만 리턴 안에서 if문의 조건문은 삼항연산자와 and조건문을 더 많이 사용한다.

4. class 대신 className을 사용한다. (id는 동일)  - class 를 사용하지 못하는 이유는 
자바스크립트에 이미 class라는 기능이 있기 때문

5. 싱글태그도 무조건 닫혀있어야 한다.
<input type='text >   ==> x
<input type='text />  ==> o

6. 인라인 스타일 기법을 사용
-인라인 스타일을 적용할때에는 className을 사용할 수 없고 객체형태로 전달해야 한다.
key값에서는 '-'을 사용할 수 없기 때문에 카멜기법으로 변환
font-size ==> fontSize

7. 태그를 직접적으로 선택하지 말 것(선택자로 지정하는 것을 남용하지 말 것)

8. css적용 방법
-class에 css를 적용할때에는 css문서를 따로 만들어서 import후에 적용
-인라인 방식으로 적용할때에는 style={{속성 : 값}}
-오브젝트로 주는 방법
-기타 모듈을 사용하는 방법(scss, style-component사용)

9. 파일명은 반드시 대문자로 시작해야 한다.(약속)
파일을 수정하거나 지우고 다시 생성할 경우 바로 인식하지 않음

네이밍규칙
모든 네이밍은 카멜기법으로 기준
-디렉토리 폴더명은 소문자
-파일명은 보통 대문자
  -component 파일은 대문자
  -그 외에 파일은 소문자
의미론적인 네이밍을 만들 것(이름이 길어져도 상관 없음)




babel과 webpack의 차이점
babel - 자바스크립트 컴파일러
es6 같은 최신 자바스크리브 코드를 모든 브라우저에서 호환할 수 있도록 호환 가능한 코드로 이전 버전의
코드로 변환하는데 사용
즉 모든 화면에서 같은 코드로 일관된 동작을 목표
jsx문법 변환 = 리액트에서 사용되는 jsx문법을 일반 자바스크립트 코드로 변환


webpack - 자바스크립트 모듈 번들러
자바스크립트, css, 이미지, 폰트, 동영상과 같은 자원(assest)를 모아서 하나 또는 여러개의 번들러를
만들어 준다.

*/

//if문으로 삼항연산자 대체
function user(userState) {
  //if문으로 삼항연산자 대체
  if (userState === "admin") {
    return <p>admin</p>;
  } else if (userState === "user") {
    return <p>user</p>;
  } else {
    return <p>guest</p>;
  }
}

function App() {
  const userState = "aaaa";
  // 오브젝트 css 적용방법
  const styleItem = {
    width: "100px",
    height: "100px",
    backgroundColor: "green",
  };

  const name = "박종호";
  /*
  if문은 return문 안에서는 사용할 수 없다.(jsx문법에서 사용 불가)
  보통 내부에서 사용하기 위해서 인라인 기법인 삼항연산자나 &&조건문을 이용하며
  if문을 사용하기 위해서는 return문 밖에서 작성 후 변수로 넣은 후 return문에 적용하는 방법이 있다.
  식이 많을때에는 삼항연산자를 연속해서 사용해서 처리할 수도 있다.
  */

  return (
    <>
      <p style={{ width: "100px", height: "100px", backgroundColor: "pink" }}>
        리액트 스타일 기초
      </p>
      <p style={styleItem}>리액트 오브젝트 css 불러오기</p>
      <div className="box">
        class는 자바스크립트 약속어이기 때문에 구분하기 위해 className으로 변경
      </div>
      <p>{name}</p>
      {/* 변수를 불러오는 방법 ==  {변수명} */}
      {/* 주석은 {}로 감싸서 작성 */}
      {name === "park" ? <p>pjh</p> : <p>jh</p>}{" "}
      {/* 삼항연산자로 조건에 따라 다른 텍스트로 사용하는 방법 */}
      {name === "박종호" && <p>{name}</p>} {/* &&조건문으로 텍스트 출력 */}
      {user(userState)}{" "}
      {/* if문을 작석하지 못하므로 함수로 if문을 작성 후 출력 */}
      {/* 연속 삼항 연산자 연속 */}
      {userState === "admin" ? (
        <p>admin</p>
      ) : userState === "aaaa" ? (
        <p>user</p>
      ) : (
        <p>guest</p>
      )}
    </>
  );
}

export default App;
